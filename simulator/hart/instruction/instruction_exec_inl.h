/*
 * This file is autogenerated by 'generate.py' script from risc-v.yaml file
 * This file can be changed without additional autogeneration
 ***********************************************************
 * Written by Glaz Roman (Vokerlee)
 */

#include "common/utils/bit_ops.h"
#include "common/macros.h"
#include "hart/exception.h"

#include <err.h>
#include <sysexits.h>
#include <iostream>

namespace rvsim {
namespace iexec {

ALWAYS_INLINE Exception BEQ(Hart *hart, const Instruction &instr)
{
    if (hart->GetGPR(instr.rs1) == hart->GetGPR(instr.rs2))
        hart->SetPCTarget(hart->GetPC() + instr.imm);
    else
        hart->SetPCTarget(hart->GetPC() + sizeof(instr_size_t));

    return Exception::NONE;
}

ALWAYS_INLINE Exception BNE(Hart *hart, const Instruction &instr)
{
    if (hart->GetGPR(instr.rs1) != hart->GetGPR(instr.rs2))
        hart->SetPCTarget(hart->GetPC() + instr.imm);
    else
        hart->SetPCTarget(hart->GetPC() + sizeof(instr_size_t));

    return Exception::NONE;
}

ALWAYS_INLINE Exception BLT(Hart *hart, const Instruction &instr)
{
    auto rs1 = bitops::MakeSigned(hart->GetGPR(instr.rs1));
    auto rs2 = bitops::MakeSigned(hart->GetGPR(instr.rs2));

    if (rs1 < rs2)
        hart->SetPCTarget(hart->GetPC() + instr.imm);
    else
        hart->SetPCTarget(hart->GetPC() + sizeof(instr_size_t));

    return Exception::NONE;
}

ALWAYS_INLINE Exception BGE(Hart *hart, const Instruction &instr)
{
    auto rs1 = bitops::MakeSigned(hart->GetGPR(instr.rs1));
    auto rs2 = bitops::MakeSigned(hart->GetGPR(instr.rs2));

    if (rs1 >= rs2)
        hart->SetPCTarget(hart->GetPC() + instr.imm);
    else
        hart->SetPCTarget(hart->GetPC() + sizeof(instr_size_t));

    return Exception::NONE;
}

ALWAYS_INLINE Exception BLTU(Hart *hart, const Instruction &instr)
{
    auto rs1 = hart->GetGPR(instr.rs1);
    auto rs2 = hart->GetGPR(instr.rs2);

    if (rs1 < rs2)
        hart->SetPCTarget(hart->GetPC() + instr.imm);
    else
        hart->SetPCTarget(hart->GetPC() + sizeof(instr_size_t));

    return Exception::NONE;
}

ALWAYS_INLINE Exception BGEU(Hart *hart, const Instruction &instr)
{
    auto rs1 = hart->GetGPR(instr.rs1);
    auto rs2 = hart->GetGPR(instr.rs2);

    if (rs1 >= rs2)
        hart->SetPCTarget(hart->GetPC() + instr.imm);
    else
        hart->SetPCTarget(hart->GetPC() + sizeof(instr_size_t));

    return Exception::NONE;
}

ALWAYS_INLINE Exception JALR(Hart *hart, const Instruction &instr)
{
    hart->SetGPR(instr.rd, hart->GetPC() + sizeof(instr_size_t));
    hart->SetPCTarget((hart->GetGPR(instr.rs1) + instr.imm) & ~reg_t {1});

    return Exception::NONE;
}

ALWAYS_INLINE Exception JAL(Hart *hart, const Instruction &instr)
{
    hart->SetGPR(instr.rd, hart->GetPC() + sizeof(instr_size_t));
    hart->SetPCTarget(hart->GetPC() + instr.imm);

    return Exception::NONE;
}

ALWAYS_INLINE Exception LUI(Hart *hart, const Instruction &instr)
{
    hart->SetGPR(instr.rd, instr.imm);
    hart->SetPCTarget(hart->GetPC() + sizeof(instr_size_t));

    return Exception::NONE;
}

ALWAYS_INLINE Exception AUIPC(Hart *hart, const Instruction &instr)
{
    hart->SetGPR(instr.rd, instr.imm + hart->GetPC());
    hart->SetPCTarget(hart->GetPC() + sizeof(instr_size_t));

    return Exception::NONE;
}

ALWAYS_INLINE Exception ADDI(Hart *hart, const Instruction &instr)
{
    reg_t rv1 = hart->GetGPR(instr.rs1);

    hart->SetGPR(instr.rd, rv1 + instr.imm);
    hart->SetPCTarget(hart->GetPC() + sizeof(instr_size_t));

    return Exception::NONE;
}

static constexpr bit_size_t RV_SH_UPPER_BIT_INDEX = 4;

ALWAYS_INLINE Exception SLLI(Hart *hart, const Instruction &instr)
{
    auto rv1 = hart->GetGPR(instr.rs1);
    auto imm = bitops::GetBits<RV_SH_UPPER_BIT_INDEX, 0>(instr.imm);

    hart->SetGPR(instr.rd, rv1 << imm);
    hart->SetPCTarget(hart->GetPC() + sizeof(instr_size_t));

    return Exception::NONE;
}

ALWAYS_INLINE Exception SLTI(Hart *hart, const Instruction &instr)
{
    auto rv1 = bitops::MakeSigned(hart->GetGPR(instr.rs1));
    auto imm = instr.imm;

    hart->SetGPR(instr.rd, rv1 < imm);
    hart->SetPCTarget(hart->GetPC() + sizeof(instr_size_t));

    return Exception::NONE;
}

ALWAYS_INLINE Exception SLTIU(Hart *hart, const Instruction &instr)
{
    auto rv1 = hart->GetGPR(instr.rs1);
    auto imm = bitops::MakeUnsigned(instr.imm);

    hart->SetGPR(instr.rd, rv1 < imm);
    hart->SetPCTarget(hart->GetPC() + sizeof(instr_size_t));

    return Exception::NONE;
}

ALWAYS_INLINE Exception XORI(Hart *hart, const Instruction &instr)
{
    reg_t rv1 = hart->GetGPR(instr.rs1);

    hart->SetGPR(instr.rd,
                 rv1 ^ bitops::SignExtend(bitops::BitSizeof<word_t>(), bitops::BitSizeof<reg_t>(), instr.imm));
    hart->SetPCTarget(hart->GetPC() + sizeof(instr_size_t));

    return Exception::NONE;
}

ALWAYS_INLINE Exception SRLI(Hart *hart, const Instruction &instr)
{
    auto rv1 = hart->GetGPR(instr.rs1);
    auto imm = bitops::GetBits<RV_SH_UPPER_BIT_INDEX, 0>(instr.imm);

    hart->SetGPR(instr.rd, rv1 >> imm);
    hart->SetPCTarget(hart->GetPC() + sizeof(instr_size_t));

    return Exception::NONE;
}

ALWAYS_INLINE Exception SRAI(Hart *hart, const Instruction &instr)
{
    auto rv1 = hart->GetGPR(instr.rs1);
    auto imm = bitops::GetBits<RV_SH_UPPER_BIT_INDEX, 0>(instr.imm);

    rv1 >>= imm;
    rv1 = bitops::SignExtend(bitops::BitSizeof<reg_t>() - imm, bitops::BitSizeof<reg_t>(), rv1);

    hart->SetGPR(instr.rd, rv1);
    hart->SetPCTarget(hart->GetPC() + sizeof(instr_size_t));

    return Exception::NONE;
}

ALWAYS_INLINE Exception ORI(Hart *hart, const Instruction &instr)
{
    reg_t rv1 = hart->GetGPR(instr.rs1);

    hart->SetGPR(instr.rd,
                 rv1 | bitops::SignExtend(bitops::BitSizeof<word_t>(), bitops::BitSizeof<reg_t>(), instr.imm));
    hart->SetPCTarget(hart->GetPC() + sizeof(instr_size_t));

    return Exception::NONE;
}

ALWAYS_INLINE Exception ANDI(Hart *hart, const Instruction &instr)
{
    reg_t rv1 = hart->GetGPR(instr.rs1);

    hart->SetGPR(instr.rd,
                 rv1 & bitops::SignExtend(bitops::BitSizeof<word_t>(), bitops::BitSizeof<reg_t>(), instr.imm));
    hart->SetPCTarget(hart->GetPC() + sizeof(instr_size_t));

    return Exception::NONE;
}

ALWAYS_INLINE Exception ADD(Hart *hart, const Instruction &instr)
{
    reg_t rv1 = hart->GetGPR(instr.rs1);
    reg_t rv2 = hart->GetGPR(instr.rs2);

    hart->SetGPR(instr.rd, rv1 + rv2);
    hart->SetPCTarget(hart->GetPC() + sizeof(instr_size_t));

    return Exception::NONE;
}

ALWAYS_INLINE Exception SUB(Hart *hart, const Instruction &instr)
{
    reg_t rv1 = hart->GetGPR(instr.rs1);
    reg_t rv2 = hart->GetGPR(instr.rs2);

    hart->SetGPR(instr.rd, rv1 - rv2);
    hart->SetPCTarget(hart->GetPC() + sizeof(instr_size_t));

    return Exception::NONE;
}

ALWAYS_INLINE Exception SLL(Hart *hart, const Instruction &instr)
{
    reg_t rv1 = hart->GetGPR(instr.rs1);
    reg_t rv2 = hart->GetGPR(instr.rs2);

    hart->SetGPR(instr.rd, rv1 << bitops::GetBits<RV_SH_UPPER_BIT_INDEX, 0>(rv2));
    hart->SetPCTarget(hart->GetPC() + sizeof(instr_size_t));

    return Exception::NONE;
}

ALWAYS_INLINE Exception SLT(Hart *hart, const Instruction &instr)
{
    auto rv1 = bitops::MakeSigned(hart->GetGPR(instr.rs1));
    auto rv2 = bitops::MakeSigned(hart->GetGPR(instr.rs2));

    hart->SetGPR(instr.rd, rv1 < rv2);
    hart->SetPCTarget(hart->GetPC() + sizeof(instr_size_t));

    return Exception::NONE;
}

ALWAYS_INLINE Exception SLTU(Hart *hart, const Instruction &instr)
{
    reg_t rv1 = hart->GetGPR(instr.rs1);
    reg_t rv2 = hart->GetGPR(instr.rs2);

    hart->SetGPR(instr.rd, rv1 < rv2);
    hart->SetPCTarget(hart->GetPC() + sizeof(instr_size_t));

    return Exception::NONE;
}

ALWAYS_INLINE Exception XOR(Hart *hart, const Instruction &instr)
{
    reg_t rv1 = hart->GetGPR(instr.rs1);
    reg_t rv2 = hart->GetGPR(instr.rs2);

    hart->SetGPR(instr.rd, rv1 ^ rv2);
    hart->SetPCTarget(hart->GetPC() + sizeof(instr_size_t));

    return Exception::NONE;
}

ALWAYS_INLINE Exception SRL(Hart *hart, const Instruction &instr)
{
    reg_t rv1 = hart->GetGPR(instr.rs1);
    reg_t rv2 = hart->GetGPR(instr.rs2);

    hart->SetGPR(instr.rd, rv1 >> bitops::GetBits<RV_SH_UPPER_BIT_INDEX, 0>(rv2));
    hart->SetPCTarget(hart->GetPC() + sizeof(instr_size_t));

    return Exception::NONE;
}

ALWAYS_INLINE Exception SRA(Hart *hart, const Instruction &instr)
{
    reg_t rv1 = hart->GetGPR(instr.rs1);
    reg_t rv2 = hart->GetGPR(instr.rs2);

    auto shift = bitops::GetBits<RV_SH_UPPER_BIT_INDEX, 0>(rv2);
    rv1 >>= shift;
    rv1 = bitops::SignExtend(bitops::BitSizeof<reg_t>() - shift, bitops::BitSizeof<reg_t>(), rv1);

    hart->SetGPR(instr.rd, rv1);
    hart->SetPCTarget(hart->GetPC() + sizeof(instr_size_t));

    return Exception::NONE;
}

ALWAYS_INLINE Exception OR(Hart *hart, const Instruction &instr)
{
    reg_t rv1 = hart->GetGPR(instr.rs1);
    reg_t rv2 = hart->GetGPR(instr.rs2);

    hart->SetGPR(instr.rd, rv1 | rv2);
    hart->SetPCTarget(hart->GetPC() + sizeof(instr_size_t));

    return Exception::NONE;
}

ALWAYS_INLINE Exception AND(Hart *hart, const Instruction &instr)
{
    reg_t rv1 = hart->GetGPR(instr.rs1);
    reg_t rv2 = hart->GetGPR(instr.rs2);

    hart->SetGPR(instr.rd, rv1 & rv2);
    hart->SetPCTarget(hart->GetPC() + sizeof(instr_size_t));

    return Exception::NONE;
}

ALWAYS_INLINE Exception ADDIW(Hart *hart, const Instruction &instr)
{
    reg_t rv1 = hart->GetGPR(instr.rs1);
    reg_t res_w = bitops::GetBits<bitops::BitSizeof<word_t>() - 1, 0>(rv1 + instr.imm);

    hart->SetGPR(instr.rd, bitops::SignExtend<bitops::BitSizeof<word_t>(), bitops::BitSizeof<reg_t>()>(res_w));
    hart->SetPCTarget(hart->GetPC() + sizeof(instr_size_t));

    return Exception::NONE;
}

ALWAYS_INLINE Exception SLLIW(Hart *hart, const Instruction &instr)
{
    reg_t rv1 = hart->GetGPR(instr.rs1);
    auto imm = bitops::GetBits<RV_SH_UPPER_BIT_INDEX, 0>(instr.imm);

    reg_t res_w = bitops::GetBits<bitops::BitSizeof<word_t>() - 1, 0>(rv1 << imm);

    hart->SetGPR(instr.rd, bitops::SignExtend<bitops::BitSizeof<word_t>(), bitops::BitSizeof<reg_t>()>(res_w));
    hart->SetPCTarget(hart->GetPC() + sizeof(instr_size_t));

    return Exception::NONE;
}

ALWAYS_INLINE Exception SRLIW(Hart *hart, const Instruction &instr)
{
    reg_t rv1 = hart->GetGPR(instr.rs1);
    auto imm = bitops::GetBits<RV_SH_UPPER_BIT_INDEX, 0>(instr.imm);

    reg_t res_w = bitops::GetBits<bitops::BitSizeof<word_t>() - 1, 0>(rv1 >> imm);

    hart->SetGPR(instr.rd, bitops::SignExtend<bitops::BitSizeof<word_t>(), bitops::BitSizeof<reg_t>()>(res_w));
    hart->SetPCTarget(hart->GetPC() + sizeof(instr_size_t));

    return Exception::NONE;
}

ALWAYS_INLINE Exception SRAIW(Hart *hart, const Instruction &instr)
{
    reg_t rv1 = hart->GetGPR(instr.rs1);
    auto imm = bitops::GetBits<RV_SH_UPPER_BIT_INDEX, 0>(instr.imm);

    reg_t res_w = bitops::GetBits<bitops::BitSizeof<word_t>() - 1, 0>(rv1 >> imm);

    hart->SetGPR(instr.rd, bitops::SignExtend(bitops::BitSizeof<word_t>() - imm, bitops::BitSizeof<reg_t>(), res_w));
    hart->SetPCTarget(hart->GetPC() + sizeof(instr_size_t));

    return Exception::NONE;
}

ALWAYS_INLINE Exception ADDW(Hart *hart, const Instruction &instr)
{
    reg_t rv1 = hart->GetGPR(instr.rs1);
    reg_t rv2 = hart->GetGPR(instr.rs2);

    reg_t res_w = bitops::GetBits<bitops::BitSizeof<word_t>() - 1, 0>(rv1 + rv2);

    hart->SetGPR(instr.rd, bitops::SignExtend<bitops::BitSizeof<word_t>(), bitops::BitSizeof<reg_t>()>(res_w));
    hart->SetPCTarget(hart->GetPC() + sizeof(instr_size_t));

    return Exception::NONE;
}

ALWAYS_INLINE Exception SUBW(Hart *hart, const Instruction &instr)
{
    reg_t rv1 = hart->GetGPR(instr.rs1);
    reg_t rv2 = hart->GetGPR(instr.rs2);

    reg_t res_w = bitops::GetBits<bitops::BitSizeof<word_t>() - 1, 0>(rv1 - rv2);

    hart->SetGPR(instr.rd, bitops::SignExtend<bitops::BitSizeof<word_t>(), bitops::BitSizeof<reg_t>()>(res_w));
    hart->SetPCTarget(hart->GetPC() + sizeof(instr_size_t));

    return Exception::NONE;
}

ALWAYS_INLINE Exception SLLW(Hart *hart, const Instruction &instr)
{
    reg_t rv1 = hart->GetGPR(instr.rs1);
    reg_t rv2 = hart->GetGPR(instr.rs2);

    reg_t res_w =
        bitops::GetBits<bitops::BitSizeof<word_t>() - 1, 0>(rv1 << bitops::GetBits<RV_SH_UPPER_BIT_INDEX, 0>(rv2));

    hart->SetGPR(instr.rd, bitops::SignExtend<bitops::BitSizeof<word_t>(), bitops::BitSizeof<reg_t>()>(res_w));
    hart->SetPCTarget(hart->GetPC() + sizeof(instr_size_t));

    return Exception::NONE;
}

ALWAYS_INLINE Exception SRLW(Hart *hart, const Instruction &instr)
{
    reg_t rv1 = hart->GetGPR(instr.rs1);
    reg_t rv2 = hart->GetGPR(instr.rs2);

    reg_t res_w =
        bitops::GetBits<bitops::BitSizeof<word_t>() - 1, 0>(rv1 >> bitops::GetBits<RV_SH_UPPER_BIT_INDEX, 0>(rv2));

    hart->SetGPR(instr.rd, bitops::SignExtend<bitops::BitSizeof<word_t>(), bitops::BitSizeof<reg_t>()>(res_w));
    hart->SetPCTarget(hart->GetPC() + sizeof(instr_size_t));

    return Exception::NONE;
}

ALWAYS_INLINE Exception SRAW(Hart *hart, const Instruction &instr)
{
    reg_t rv1 = hart->GetGPR(instr.rs1);
    reg_t rv2 = hart->GetGPR(instr.rs2);

    auto shift = bitops::GetBits<RV_SH_UPPER_BIT_INDEX, 0>(rv2);
    reg_t res_w = bitops::GetBits<bitops::BitSizeof<word_t>() - 1, 0>(rv1 >> shift);
    rv1 = bitops::SignExtend(bitops::BitSizeof<reg_t>() - shift, bitops::BitSizeof<reg_t>(), rv1);

    hart->SetGPR(instr.rd, bitops::SignExtend(bitops::BitSizeof<word_t>() - shift, bitops::BitSizeof<reg_t>(), res_w));
    hart->SetPCTarget(hart->GetPC() + sizeof(instr_size_t));

    return Exception::NONE;
}

ALWAYS_INLINE Exception LB(Hart *hart, const Instruction &instr)
{
    auto rv1 = hart->GetGPR(instr.rs1);

    using load_type_t = std::make_signed_t<byte_t>;
    load_type_t load_value {0};

    Exception exception = hart->LoadFromMemory<load_type_t>(rv1 + instr.imm, &load_value);
    hart->SetGPR(instr.rd, load_value);
    hart->SetPCTarget(hart->GetPC() + sizeof(instr_size_t));

    return exception;
}

ALWAYS_INLINE Exception LH(Hart *hart, const Instruction &instr)
{
    auto rv1 = hart->GetGPR(instr.rs1);

    using load_type_t = std::make_signed_t<hword_t>;
    load_type_t load_value {0};

    Exception exception = hart->LoadFromMemory<load_type_t>(rv1 + instr.imm, &load_value);
    hart->SetGPR(instr.rd, load_value);
    hart->SetPCTarget(hart->GetPC() + sizeof(instr_size_t));

    return exception;
}

ALWAYS_INLINE Exception LW(Hart *hart, const Instruction &instr)
{
    auto rv1 = hart->GetGPR(instr.rs1);

    using load_type_t = std::make_signed_t<word_t>;
    load_type_t load_value {0};

    Exception exception = hart->LoadFromMemory<load_type_t>(rv1 + instr.imm, &load_value);
    hart->SetGPR(instr.rd, load_value);
    hart->SetPCTarget(hart->GetPC() + sizeof(instr_size_t));

    return exception;
}

ALWAYS_INLINE Exception LD(Hart *hart, const Instruction &instr)
{
    auto rv1 = hart->GetGPR(instr.rs1);

    using load_type_t = dword_t;
    load_type_t load_value {0};

    Exception exception = hart->LoadFromMemory<load_type_t>(rv1 + instr.imm, &load_value);
    hart->SetGPR(instr.rd, load_value);
    hart->SetPCTarget(hart->GetPC() + sizeof(instr_size_t));

    return exception;
}

ALWAYS_INLINE Exception LBU(Hart *hart, const Instruction &instr)
{
    auto rv1 = hart->GetGPR(instr.rs1);

    using load_type_t = byte_t;
    load_type_t load_value {0};

    Exception exception = hart->LoadFromMemory<load_type_t>(rv1 + instr.imm, &load_value);
    hart->SetGPR(instr.rd, load_value);
    hart->SetPCTarget(hart->GetPC() + sizeof(instr_size_t));

    return exception;
}

ALWAYS_INLINE Exception LHU(Hart *hart, const Instruction &instr)
{
    auto rv1 = hart->GetGPR(instr.rs1);

    using load_type_t = hword_t;
    load_type_t load_value {0};

    Exception exception = hart->LoadFromMemory<load_type_t>(rv1 + instr.imm, &load_value);
    hart->SetGPR(instr.rd, load_value);
    hart->SetPCTarget(hart->GetPC() + sizeof(instr_size_t));

    return exception;
}

ALWAYS_INLINE Exception LWU(Hart *hart, const Instruction &instr)
{
    auto rv1 = hart->GetGPR(instr.rs1);

    using load_type_t = word_t;
    load_type_t load_value {0};

    Exception exception = hart->LoadFromMemory<load_type_t>(rv1 + instr.imm, &load_value);
    hart->SetGPR(instr.rd, load_value);
    hart->SetPCTarget(hart->GetPC() + sizeof(instr_size_t));

    return exception;
}

ALWAYS_INLINE Exception SB(Hart *hart, const Instruction &instr)
{
    auto rv1 = hart->GetGPR(instr.rs1);
    byte_t rv2 = hart->GetGPR(instr.rs2);

    Exception exception = hart->StoreToMemory<byte_t>(rv1 + instr.imm, rv2);
    hart->SetPCTarget(hart->GetPC() + sizeof(instr_size_t));

    return exception;
}

ALWAYS_INLINE Exception SH(Hart *hart, const Instruction &instr)
{
    auto rv1 = hart->GetGPR(instr.rs1);
    hword_t rv2 = hart->GetGPR(instr.rs2);

    Exception exception = hart->StoreToMemory<hword_t>(rv1 + instr.imm, rv2);
    hart->SetPCTarget(hart->GetPC() + sizeof(instr_size_t));

    return exception;
}

ALWAYS_INLINE Exception SW(Hart *hart, const Instruction &instr)
{
    auto rv1 = hart->GetGPR(instr.rs1);
    word_t rv2 = hart->GetGPR(instr.rs2);

    Exception exception = hart->StoreToMemory<word_t>(rv1 + instr.imm, rv2);
    hart->SetPCTarget(hart->GetPC() + sizeof(instr_size_t));

    return exception;
}

ALWAYS_INLINE Exception SD(Hart *hart, const Instruction &instr)
{
    auto rv1 = hart->GetGPR(instr.rs1);
    dword_t rv2 = hart->GetGPR(instr.rs2);

    Exception exception = hart->StoreToMemory<dword_t>(rv1 + instr.imm, rv2);
    hart->SetPCTarget(hart->GetPC() + sizeof(instr_size_t));

    return exception;
}

ALWAYS_INLINE Exception FENCE(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FENCE(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception FENCE_I(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FENCE_I(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception MUL(Hart *hart, const Instruction &instr)
{
    reg_t rv1 = hart->GetGPR(instr.rs1);
    reg_t rv2 = hart->GetGPR(instr.rs2);

    hart->SetGPR(instr.rd, rv1 * rv2);
    hart->SetPCTarget(hart->GetPC() + sizeof(instr_size_t));

    return Exception::NONE;
}

ALWAYS_INLINE Exception MULH(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::MULH(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception MULHSU(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::MULHSU(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception MULHU(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::MULHU(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception DIV(Hart *hart, const Instruction &instr)
{
    auto rv1 = bitops::MakeSigned(hart->GetGPR(instr.rs1));
    auto rv2 = bitops::MakeSigned(hart->GetGPR(instr.rs2));

    hart->SetGPR(instr.rd, rv1 / rv2);
    hart->SetPCTarget(hart->GetPC() + sizeof(instr_size_t));

    return Exception::NONE;
}

ALWAYS_INLINE Exception DIVU(Hart *hart, const Instruction &instr)
{
    reg_t rv1 = hart->GetGPR(instr.rs1);
    reg_t rv2 = hart->GetGPR(instr.rs2);

    hart->SetGPR(instr.rd, rv1 / rv2);
    hart->SetPCTarget(hart->GetPC() + sizeof(instr_size_t));

    return Exception::NONE;
}

ALWAYS_INLINE Exception REM(Hart *hart, const Instruction &instr)
{
    auto rv1 = bitops::MakeSigned(hart->GetGPR(instr.rs1));
    auto rv2 = bitops::MakeSigned(hart->GetGPR(instr.rs2));

    hart->SetGPR(instr.rd, rv1 % rv2);
    hart->SetPCTarget(hart->GetPC() + sizeof(instr_size_t));

    return Exception::NONE;
}

ALWAYS_INLINE Exception REMU(Hart *hart, const Instruction &instr)
{
    reg_t rv1 = hart->GetGPR(instr.rs1);
    reg_t rv2 = hart->GetGPR(instr.rs2);

    hart->SetGPR(instr.rd, rv1 % rv2);
    hart->SetPCTarget(hart->GetPC() + sizeof(instr_size_t));

    return Exception::NONE;
}

ALWAYS_INLINE Exception MULW(Hart *hart, const Instruction &instr)
{
    reg_t rv1 = hart->GetGPR(instr.rs1);
    reg_t rv2 = hart->GetGPR(instr.rs2);

    rv1 = bitops::GetBits<bitops::BitSizeof<word_t>() - 1, 0>(rv1);
    rv1 = bitops::SignExtend<bitops::BitSizeof<word_t>(), bitops::BitSizeof<reg_t>()>(rv1);

    rv2 = bitops::GetBits<bitops::BitSizeof<word_t>() - 1, 0>(rv2);
    rv2 = bitops::SignExtend<bitops::BitSizeof<word_t>(), bitops::BitSizeof<reg_t>()>(rv2);

    reg_t res_w = bitops::GetBits<bitops::BitSizeof<word_t>() - 1, 0>(rv1 * rv2);

    hart->SetGPR(instr.rd, bitops::SignExtend<bitops::BitSizeof<word_t>(), bitops::BitSizeof<reg_t>()>(res_w));
    hart->SetPCTarget(hart->GetPC() + sizeof(instr_size_t));

    return Exception::NONE;
}

ALWAYS_INLINE Exception DIVW(Hart *hart, const Instruction &instr)
{
    auto rv1 = bitops::MakeSigned(hart->GetGPR(instr.rs1));
    auto rv2 = bitops::MakeSigned(hart->GetGPR(instr.rs2));

    rv1 = bitops::GetBits<bitops::BitSizeof<word_t>() - 1, 0>(rv1);
    rv1 = bitops::SignExtend<bitops::BitSizeof<word_t>(), bitops::BitSizeof<reg_t>()>(rv1);

    rv2 = bitops::GetBits<bitops::BitSizeof<word_t>() - 1, 0>(rv2);
    rv2 = bitops::SignExtend<bitops::BitSizeof<word_t>(), bitops::BitSizeof<reg_t>()>(rv2);

    reg_t res_w = bitops::GetBits<bitops::BitSizeof<word_t>() - 1, 0>(rv1 / rv2);

    hart->SetGPR(instr.rd, bitops::SignExtend<bitops::BitSizeof<word_t>(), bitops::BitSizeof<reg_t>()>(res_w));
    hart->SetPCTarget(hart->GetPC() + sizeof(instr_size_t));

    return Exception::NONE;
}

ALWAYS_INLINE Exception DIVUW(Hart *hart, const Instruction &instr)
{
    reg_t rv1 = hart->GetGPR(instr.rs1);
    reg_t rv2 = hart->GetGPR(instr.rs2);

    rv1 = bitops::GetBits<bitops::BitSizeof<word_t>() - 1, 0>(rv1);
    rv1 = bitops::SignExtend<bitops::BitSizeof<word_t>(), bitops::BitSizeof<reg_t>()>(rv1);

    rv2 = bitops::GetBits<bitops::BitSizeof<word_t>() - 1, 0>(rv2);
    rv2 = bitops::SignExtend<bitops::BitSizeof<word_t>(), bitops::BitSizeof<reg_t>()>(rv2);

    reg_t res_w = bitops::GetBits<bitops::BitSizeof<word_t>() - 1, 0>(rv1 / rv2);

    hart->SetGPR(instr.rd, bitops::SignExtend<bitops::BitSizeof<word_t>(), bitops::BitSizeof<reg_t>()>(res_w));
    hart->SetPCTarget(hart->GetPC() + sizeof(instr_size_t));

    return Exception::NONE;
}

ALWAYS_INLINE Exception REMW(Hart *hart, const Instruction &instr)
{
    auto rv1 = bitops::MakeSigned(hart->GetGPR(instr.rs1));
    auto rv2 = bitops::MakeSigned(hart->GetGPR(instr.rs2));

    rv1 = bitops::GetBits<bitops::BitSizeof<word_t>() - 1, 0>(rv1);
    rv1 = bitops::SignExtend<bitops::BitSizeof<word_t>(), bitops::BitSizeof<reg_t>()>(rv1);

    rv2 = bitops::GetBits<bitops::BitSizeof<word_t>() - 1, 0>(rv2);
    rv2 = bitops::SignExtend<bitops::BitSizeof<word_t>(), bitops::BitSizeof<reg_t>()>(rv2);

    reg_t res_w = bitops::GetBits<bitops::BitSizeof<word_t>() - 1, 0>(rv1 % rv2);

    hart->SetGPR(instr.rd, bitops::SignExtend<bitops::BitSizeof<word_t>(), bitops::BitSizeof<reg_t>()>(res_w));
    hart->SetPCTarget(hart->GetPC() + sizeof(instr_size_t));

    return Exception::NONE;
}

ALWAYS_INLINE Exception REMUW(Hart *hart, const Instruction &instr)
{
    reg_t rv1 = hart->GetGPR(instr.rs1);
    reg_t rv2 = hart->GetGPR(instr.rs2);

    rv1 = bitops::GetBits<bitops::BitSizeof<word_t>() - 1, 0>(rv1);
    rv1 = bitops::SignExtend<bitops::BitSizeof<word_t>(), bitops::BitSizeof<reg_t>()>(rv1);

    rv2 = bitops::GetBits<bitops::BitSizeof<word_t>() - 1, 0>(rv2);
    rv2 = bitops::SignExtend<bitops::BitSizeof<word_t>(), bitops::BitSizeof<reg_t>()>(rv2);

    reg_t res_w = bitops::GetBits<bitops::BitSizeof<word_t>() - 1, 0>(rv1 % rv2);

    hart->SetGPR(instr.rd, bitops::SignExtend<bitops::BitSizeof<word_t>(), bitops::BitSizeof<reg_t>()>(res_w));
    hart->SetPCTarget(hart->GetPC() + sizeof(instr_size_t));

    return Exception::NONE;
}

ALWAYS_INLINE Exception AMOADD_W(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::AMOADD_W(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception AMOXOR_W(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::AMOXOR_W(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception AMOOR_W(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::AMOOR_W(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception AMOAND_W(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::AMOAND_W(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception AMOMIN_W(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::AMOMIN_W(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception AMOMAX_W(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::AMOMAX_W(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception AMOMINU_W(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::AMOMINU_W(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception AMOMAXU_W(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::AMOMAXU_W(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception AMOSWAP_W(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::AMOSWAP_W(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception LR_W(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::LR_W(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception SC_W(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::SC_W(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception AMOADD_D(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::AMOADD_D(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception AMOXOR_D(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::AMOXOR_D(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception AMOOR_D(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::AMOOR_D(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception AMOAND_D(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::AMOAND_D(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception AMOMIN_D(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::AMOMIN_D(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception AMOMAX_D(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::AMOMAX_D(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception AMOMINU_D(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::AMOMINU_D(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception AMOMAXU_D(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::AMOMAXU_D(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception AMOSWAP_D(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::AMOSWAP_D(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception LR_D(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::LR_D(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception SC_D(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::SC_D(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception ECALL(Hart *hart, [[maybe_unused]] const Instruction &instr)
{
    hart->SetIdleStatus(true);

    return Exception::NONE;
}

ALWAYS_INLINE Exception EBREAK(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::EBREAK(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception URET(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::URET(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception SRET(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::SRET(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception MRET(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::MRET(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception DRET(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::DRET(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception SFENCE_VMA(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::SFENCE_VMA(Hart *hart, const Instruction &instr) is not implemented yet!"
              << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception WFI(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::WFI(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception CSRRW(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::CSRRW(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception CSRRS(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::CSRRS(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception CSRRC(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::CSRRC(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception CSRRWI(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::CSRRWI(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception CSRRSI(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::CSRRSI(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception CSRRCI(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::CSRRCI(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception HFENCE_VVMA(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::HFENCE_VVMA(Hart *hart, const Instruction &instr) is not implemented yet!"
              << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception HFENCE_GVMA(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::HFENCE_GVMA(Hart *hart, const Instruction &instr) is not implemented yet!"
              << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception FADD_S(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FADD_S(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception FSUB_S(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FSUB_S(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception FMUL_S(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FMUL_S(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception FDIV_S(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FDIV_S(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception FSGNJ_S(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FSGNJ_S(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception FSGNJN_S(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FSGNJN_S(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception FSGNJX_S(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FSGNJX_S(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception FMIN_S(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FMIN_S(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception FMAX_S(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FMAX_S(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception FSQRT_S(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FSQRT_S(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception FADD_D(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FADD_D(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception FSUB_D(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FSUB_D(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception FMUL_D(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FMUL_D(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception FDIV_D(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FDIV_D(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception FSGNJ_D(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FSGNJ_D(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception FSGNJN_D(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FSGNJN_D(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception FSGNJX_D(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FSGNJX_D(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception FMIN_D(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FMIN_D(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception FMAX_D(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FMAX_D(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception FCVT_S_D(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FCVT_S_D(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception FCVT_D_S(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FCVT_D_S(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception FSQRT_D(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FSQRT_D(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception FADD_Q(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FADD_Q(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception FSUB_Q(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FSUB_Q(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception FMUL_Q(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FMUL_Q(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception FDIV_Q(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FDIV_Q(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception FSGNJ_Q(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FSGNJ_Q(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception FSGNJN_Q(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FSGNJN_Q(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception FSGNJX_Q(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FSGNJX_Q(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception FMIN_Q(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FMIN_Q(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception FMAX_Q(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FMAX_Q(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception FCVT_S_Q(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FCVT_S_Q(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception FCVT_Q_S(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FCVT_Q_S(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception FCVT_D_Q(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FCVT_D_Q(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception FCVT_Q_D(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FCVT_Q_D(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception FSQRT_Q(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FSQRT_Q(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception FLE_S(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FLE_S(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception FLT_S(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FLT_S(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception FEQ_S(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FEQ_S(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception FLE_D(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FLE_D(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception FLT_D(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FLT_D(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception FEQ_D(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FEQ_D(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception FLE_Q(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FLE_Q(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception FLT_Q(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FLT_Q(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception FEQ_Q(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FEQ_Q(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception FCVT_W_S(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FCVT_W_S(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception FCVT_WU_S(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FCVT_WU_S(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception FCVT_L_S(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FCVT_L_S(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception FCVT_LU_S(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FCVT_LU_S(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception FMV_X_W(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FMV_X_W(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception FCLASS_S(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FCLASS_S(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception FCVT_W_D(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FCVT_W_D(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception FCVT_WU_D(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FCVT_WU_D(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception FCVT_L_D(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FCVT_L_D(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception FCVT_LU_D(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FCVT_LU_D(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception FMV_X_D(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FMV_X_D(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception FCLASS_D(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FCLASS_D(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception FCVT_W_Q(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FCVT_W_Q(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception FCVT_WU_Q(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FCVT_WU_Q(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception FCVT_L_Q(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FCVT_L_Q(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception FCVT_LU_Q(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FCVT_LU_Q(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception FMV_X_Q(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FMV_X_Q(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception FCLASS_Q(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FCLASS_Q(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception FCVT_S_W(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FCVT_S_W(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception FCVT_S_WU(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FCVT_S_WU(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception FCVT_S_L(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FCVT_S_L(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception FCVT_S_LU(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FCVT_S_LU(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception FMV_W_X(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FMV_W_X(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception FCVT_D_W(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FCVT_D_W(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception FCVT_D_WU(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FCVT_D_WU(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception FCVT_D_L(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FCVT_D_L(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception FCVT_D_LU(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FCVT_D_LU(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception FMV_D_X(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FMV_D_X(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception FCVT_Q_W(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FCVT_Q_W(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception FCVT_Q_WU(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FCVT_Q_WU(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;
    return Exception::NONE;
}

ALWAYS_INLINE Exception FCVT_Q_L(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FCVT_Q_L(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception FCVT_Q_LU(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FCVT_Q_LU(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception FMV_Q_X(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FMV_Q_X(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception FLW(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FLW(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception FLD(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FLD(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception FLQ(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FLQ(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception FSW(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FSW(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception FSD(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FSD(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception FSQ(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FSQ(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception FMADD_S(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FMADD_S(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception FMSUB_S(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FMSUB_S(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception FNMSUB_S(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FNMSUB_S(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception FNMADD_S(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FNMADD_S(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception FMADD_D(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FMADD_D(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception FMSUB_D(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FMSUB_D(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception FNMSUB_D(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FNMSUB_D(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception FNMADD_D(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FNMADD_D(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception FMADD_Q(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FMADD_Q(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception FMSUB_Q(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FMSUB_Q(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception FNMSUB_Q(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FNMSUB_Q(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception FNMADD_Q(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FNMADD_Q(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

ALWAYS_INLINE Exception INVALID([[maybe_unused]] Hart *hart, [[maybe_unused]] const Instruction &instr)
{
    // TODO(skurnevich): change abort to hart->SetException(InvalidInstr)
    err(EX_DATAERR, "Invalid instruction\n");

    return Exception::NONE;
}

} // namespace iexec

} // namespace rvsim
