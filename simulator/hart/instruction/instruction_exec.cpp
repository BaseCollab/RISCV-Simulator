/*
 * This file is autogenerated by 'generate.py' script from risc-v.yaml file
 * This file can be changed without additional autogeneration
 ***********************************************************
 * Written by Glaz Roman (Vokerlee)
 */

#include "common/utils/bit_ops.h"
#include "hart/instruction/instruction_exec.h"
#include "hart/exception.h"

#include <err.h>
#include <sysexits.h>
#include <iostream>

namespace rvsim {
namespace iexec {

Exception BEQ(Hart *hart, const Instruction &instr)
{
    if (hart->GetGPR(instr.rs1) == hart->GetGPR(instr.rs2))
        hart->SetPCTarget(hart->GetPC() + instr.imm);
    else
        hart->SetPCTarget(hart->GetPC() + sizeof(instr_size_t));

    return Exception::NONE;
}

Exception BNE(Hart *hart, const Instruction &instr)
{
    if (hart->GetGPR(instr.rs1) != hart->GetGPR(instr.rs2))
        hart->SetPCTarget(hart->GetPC() + instr.imm);
    else
        hart->SetPCTarget(hart->GetPC() + sizeof(instr_size_t));

    return Exception::NONE;
}

Exception BLT(Hart *hart, const Instruction &instr)
{
    auto rs1 = bitops::MakeSigned(hart->GetGPR(instr.rs1));
    auto rs2 = bitops::MakeSigned(hart->GetGPR(instr.rs2));

    if (rs1 < rs2)
        hart->SetPCTarget(hart->GetPC() + instr.imm);
    else
        hart->SetPCTarget(hart->GetPC() + sizeof(instr_size_t));

    return Exception::NONE;
}

Exception BGE(Hart *hart, const Instruction &instr)
{
    auto rs1 = bitops::MakeSigned(hart->GetGPR(instr.rs1));
    auto rs2 = bitops::MakeSigned(hart->GetGPR(instr.rs2));

    if (rs1 >= rs2)
        hart->SetPCTarget(hart->GetPC() + instr.imm);
    else
        hart->SetPCTarget(hart->GetPC() + sizeof(instr_size_t));

    return Exception::NONE;
}

Exception BLTU(Hart *hart, const Instruction &instr)
{
    auto rs1 = hart->GetGPR(instr.rs1);
    auto rs2 = hart->GetGPR(instr.rs2);

    if (rs1 < rs2)
        hart->SetPCTarget(hart->GetPC() + instr.imm);
    else
        hart->SetPCTarget(hart->GetPC() + sizeof(instr_size_t));

    return Exception::NONE;
}

Exception BGEU(Hart *hart, const Instruction &instr)
{
    auto rs1 = hart->GetGPR(instr.rs1);
    auto rs2 = hart->GetGPR(instr.rs2);

    if (rs1 >= rs2)
        hart->SetPCTarget(hart->GetPC() + instr.imm);
    else
        hart->SetPCTarget(hart->GetPC() + sizeof(instr_size_t));

    return Exception::NONE;
}

Exception JALR(Hart *hart, const Instruction &instr)
{
    hart->SetGPR(instr.rd, hart->GetPC() + sizeof(instr_size_t));
    hart->SetPCTarget((hart->GetGPR(instr.rs1) + instr.imm) & ~reg_t {1});

    return Exception::NONE;
}

Exception JAL(Hart *hart, const Instruction &instr)
{
    hart->SetGPR(instr.rd, hart->GetPC() + sizeof(instr_size_t));
    hart->SetPCTarget(hart->GetPC() + instr.imm);

    return Exception::NONE;
}

Exception LUI(Hart *hart, const Instruction &instr)
{
    hart->SetGPR(instr.rd, instr.imm);
    hart->SetPCTarget(hart->GetPC() + sizeof(instr_size_t));

    return Exception::NONE;
}

Exception AUIPC(Hart *hart, const Instruction &instr)
{
    hart->SetGPR(instr.rd, instr.imm + hart->GetPC());
    hart->SetPCTarget(hart->GetPC() + sizeof(instr_size_t));

    return Exception::NONE;
}

Exception ADDI(Hart *hart, const Instruction &instr)
{
    reg_t rv1 = hart->GetGPR(instr.rs1);

    hart->SetGPR(instr.rd, rv1 + instr.imm);
    hart->SetPCTarget(hart->GetPC() + sizeof(instr_size_t));

    return Exception::NONE;
}

static constexpr bit_size_t RV_SH_UPPER_BIT_INDEX = 4;

Exception SLLI(Hart *hart, const Instruction &instr)
{
    auto rv1 = hart->GetGPR(instr.rs1);
    auto imm = bitops::GetBits<RV_SH_UPPER_BIT_INDEX, 0>(instr.imm);

    hart->SetGPR(instr.rd, rv1 << imm);
    hart->SetPCTarget(hart->GetPC() + sizeof(instr_size_t));

    return Exception::NONE;
}

Exception SLTI(Hart *hart, const Instruction &instr)
{
    auto rv1 = bitops::MakeSigned(hart->GetGPR(instr.rs1));
    auto imm = instr.imm;

    hart->SetGPR(instr.rd, rv1 < imm);
    hart->SetPCTarget(hart->GetPC() + sizeof(instr_size_t));

    return Exception::NONE;
}

Exception SLTIU(Hart *hart, const Instruction &instr)
{
    auto rv1 = hart->GetGPR(instr.rs1);
    auto imm = bitops::MakeUnsigned(instr.imm);

    hart->SetGPR(instr.rd, rv1 < imm);
    hart->SetPCTarget(hart->GetPC() + sizeof(instr_size_t));

    return Exception::NONE;
}

Exception XORI(Hart *hart, const Instruction &instr)
{
    reg_t rv1 = hart->GetGPR(instr.rs1);

    hart->SetGPR(instr.rd,
                 rv1 ^ bitops::SignExtend(bitops::BitSizeof<word_t>(), bitops::BitSizeof<reg_t>(), instr.imm));
    hart->SetPCTarget(hart->GetPC() + sizeof(instr_size_t));

    return Exception::NONE;
}

Exception SRLI(Hart *hart, const Instruction &instr)
{
    auto rv1 = hart->GetGPR(instr.rs1);
    auto imm = bitops::GetBits<RV_SH_UPPER_BIT_INDEX, 0>(instr.imm);

    hart->SetGPR(instr.rd, rv1 >> imm);
    hart->SetPCTarget(hart->GetPC() + sizeof(instr_size_t));

    return Exception::NONE;
}

Exception SRAI(Hart *hart, const Instruction &instr)
{
    auto rv1 = hart->GetGPR(instr.rs1);
    auto imm = bitops::GetBits<RV_SH_UPPER_BIT_INDEX, 0>(instr.imm);

    rv1 >>= imm;
    rv1 = bitops::SignExtend(bitops::BitSizeof<reg_t>() - imm, bitops::BitSizeof<reg_t>(), rv1);

    hart->SetGPR(instr.rd, rv1);
    hart->SetPCTarget(hart->GetPC() + sizeof(instr_size_t));

    return Exception::NONE;
}

Exception ORI(Hart *hart, const Instruction &instr)
{
    reg_t rv1 = hart->GetGPR(instr.rs1);

    hart->SetGPR(instr.rd,
                 rv1 | bitops::SignExtend(bitops::BitSizeof<word_t>(), bitops::BitSizeof<reg_t>(), instr.imm));
    hart->SetPCTarget(hart->GetPC() + sizeof(instr_size_t));

    return Exception::NONE;
}

Exception ANDI(Hart *hart, const Instruction &instr)
{
    reg_t rv1 = hart->GetGPR(instr.rs1);

    hart->SetGPR(instr.rd,
                 rv1 & bitops::SignExtend(bitops::BitSizeof<word_t>(), bitops::BitSizeof<reg_t>(), instr.imm));
    hart->SetPCTarget(hart->GetPC() + sizeof(instr_size_t));

    return Exception::NONE;
}

Exception ADD(Hart *hart, const Instruction &instr)
{
    reg_t rv1 = hart->GetGPR(instr.rs1);
    reg_t rv2 = hart->GetGPR(instr.rs2);

    hart->SetGPR(instr.rd, rv1 + rv2);
    hart->SetPCTarget(hart->GetPC() + sizeof(instr_size_t));

    return Exception::NONE;
}

Exception SUB(Hart *hart, const Instruction &instr)
{
    reg_t rv1 = hart->GetGPR(instr.rs1);
    reg_t rv2 = hart->GetGPR(instr.rs2);

    hart->SetGPR(instr.rd, rv1 - rv2);
    hart->SetPCTarget(hart->GetPC() + sizeof(instr_size_t));

    return Exception::NONE;
}

Exception SLL(Hart *hart, const Instruction &instr)
{
    reg_t rv1 = hart->GetGPR(instr.rs1);
    reg_t rv2 = hart->GetGPR(instr.rs2);

    hart->SetGPR(instr.rd, rv1 << bitops::GetBits<RV_SH_UPPER_BIT_INDEX, 0>(rv2));
    hart->SetPCTarget(hart->GetPC() + sizeof(instr_size_t));

    return Exception::NONE;
}

Exception SLT(Hart *hart, const Instruction &instr)
{
    auto rv1 = bitops::MakeSigned(hart->GetGPR(instr.rs1));
    auto rv2 = bitops::MakeSigned(hart->GetGPR(instr.rs2));

    hart->SetGPR(instr.rd, rv1 < rv2);
    hart->SetPCTarget(hart->GetPC() + sizeof(instr_size_t));

    return Exception::NONE;
}

Exception SLTU(Hart *hart, const Instruction &instr)
{
    reg_t rv1 = hart->GetGPR(instr.rs1);
    reg_t rv2 = hart->GetGPR(instr.rs2);

    hart->SetGPR(instr.rd, rv1 < rv2);
    hart->SetPCTarget(hart->GetPC() + sizeof(instr_size_t));

    return Exception::NONE;
}

Exception XOR(Hart *hart, const Instruction &instr)
{
    reg_t rv1 = hart->GetGPR(instr.rs1);
    reg_t rv2 = hart->GetGPR(instr.rs2);

    hart->SetGPR(instr.rd, rv1 ^ rv2);
    hart->SetPCTarget(hart->GetPC() + sizeof(instr_size_t));

    return Exception::NONE;
}

Exception SRL(Hart *hart, const Instruction &instr)
{
    reg_t rv1 = hart->GetGPR(instr.rs1);
    reg_t rv2 = hart->GetGPR(instr.rs2);

    hart->SetGPR(instr.rd, rv1 >> bitops::GetBits<RV_SH_UPPER_BIT_INDEX, 0>(rv2));
    hart->SetPCTarget(hart->GetPC() + sizeof(instr_size_t));

    return Exception::NONE;
}

Exception SRA(Hart *hart, const Instruction &instr)
{
    reg_t rv1 = hart->GetGPR(instr.rs1);
    reg_t rv2 = hart->GetGPR(instr.rs2);

    auto shift = bitops::GetBits<RV_SH_UPPER_BIT_INDEX, 0>(rv2);
    rv1 >>= shift;
    rv1 = bitops::SignExtend(bitops::BitSizeof<reg_t>() - shift, bitops::BitSizeof<reg_t>(), rv1);

    hart->SetGPR(instr.rd, rv1);
    hart->SetPCTarget(hart->GetPC() + sizeof(instr_size_t));

    return Exception::NONE;
}

Exception OR(Hart *hart, const Instruction &instr)
{
    reg_t rv1 = hart->GetGPR(instr.rs1);
    reg_t rv2 = hart->GetGPR(instr.rs2);

    hart->SetGPR(instr.rd, rv1 | rv2);
    hart->SetPCTarget(hart->GetPC() + sizeof(instr_size_t));

    return Exception::NONE;
}

Exception AND(Hart *hart, const Instruction &instr)
{
    reg_t rv1 = hart->GetGPR(instr.rs1);
    reg_t rv2 = hart->GetGPR(instr.rs2);

    hart->SetGPR(instr.rd, rv1 & rv2);
    hart->SetPCTarget(hart->GetPC() + sizeof(instr_size_t));

    return Exception::NONE;
}

Exception ADDIW(Hart *hart, const Instruction &instr)
{
    reg_t rv1 = hart->GetGPR(instr.rs1);
    reg_t res_w = bitops::GetBits<bitops::BitSizeof<word_t>() - 1, 0>(rv1 + instr.imm);

    hart->SetGPR(instr.rd, bitops::SignExtend<bitops::BitSizeof<word_t>(), bitops::BitSizeof<reg_t>()>(res_w));
    hart->SetPCTarget(hart->GetPC() + sizeof(instr_size_t));

    return Exception::NONE;
}

Exception SLLIW(Hart *hart, const Instruction &instr)
{
    reg_t rv1 = hart->GetGPR(instr.rs1);
    auto imm = bitops::GetBits<RV_SH_UPPER_BIT_INDEX, 0>(instr.imm);

    reg_t res_w = bitops::GetBits<bitops::BitSizeof<word_t>() - 1, 0>(rv1 << imm);

    hart->SetGPR(instr.rd, bitops::SignExtend<bitops::BitSizeof<word_t>(), bitops::BitSizeof<reg_t>()>(res_w));
    hart->SetPCTarget(hart->GetPC() + sizeof(instr_size_t));

    return Exception::NONE;
}

Exception SRLIW(Hart *hart, const Instruction &instr)
{
    reg_t rv1 = hart->GetGPR(instr.rs1);
    auto imm = bitops::GetBits<RV_SH_UPPER_BIT_INDEX, 0>(instr.imm);

    reg_t res_w = bitops::GetBits<bitops::BitSizeof<word_t>() - 1, 0>(rv1 >> imm);

    hart->SetGPR(instr.rd, bitops::SignExtend<bitops::BitSizeof<word_t>(), bitops::BitSizeof<reg_t>()>(res_w));
    hart->SetPCTarget(hart->GetPC() + sizeof(instr_size_t));

    return Exception::NONE;
}

Exception SRAIW(Hart *hart, const Instruction &instr)
{
    reg_t rv1 = hart->GetGPR(instr.rs1);
    auto imm = bitops::GetBits<RV_SH_UPPER_BIT_INDEX, 0>(instr.imm);

    reg_t res_w = bitops::GetBits<bitops::BitSizeof<word_t>() - 1, 0>(rv1 >> imm);

    hart->SetGPR(instr.rd, bitops::SignExtend(bitops::BitSizeof<word_t>() - imm, bitops::BitSizeof<reg_t>(), res_w));
    hart->SetPCTarget(hart->GetPC() + sizeof(instr_size_t));

    return Exception::NONE;
}

Exception ADDW(Hart *hart, const Instruction &instr)
{
    reg_t rv1 = hart->GetGPR(instr.rs1);
    reg_t rv2 = hart->GetGPR(instr.rs2);

    reg_t res_w = bitops::GetBits<bitops::BitSizeof<word_t>() - 1, 0>(rv1 + rv2);

    hart->SetGPR(instr.rd, bitops::SignExtend<bitops::BitSizeof<word_t>(), bitops::BitSizeof<reg_t>()>(res_w));
    hart->SetPCTarget(hart->GetPC() + sizeof(instr_size_t));

    return Exception::NONE;
}

Exception SUBW(Hart *hart, const Instruction &instr)
{
    reg_t rv1 = hart->GetGPR(instr.rs1);
    reg_t rv2 = hart->GetGPR(instr.rs2);

    reg_t res_w = bitops::GetBits<bitops::BitSizeof<word_t>() - 1, 0>(rv1 - rv2);

    hart->SetGPR(instr.rd, bitops::SignExtend<bitops::BitSizeof<word_t>(), bitops::BitSizeof<reg_t>()>(res_w));
    hart->SetPCTarget(hart->GetPC() + sizeof(instr_size_t));

    return Exception::NONE;
}

Exception SLLW(Hart *hart, const Instruction &instr)
{
    reg_t rv1 = hart->GetGPR(instr.rs1);
    reg_t rv2 = hart->GetGPR(instr.rs2);

    reg_t res_w =
        bitops::GetBits<bitops::BitSizeof<word_t>() - 1, 0>(rv1 << bitops::GetBits<RV_SH_UPPER_BIT_INDEX, 0>(rv2));

    hart->SetGPR(instr.rd, bitops::SignExtend<bitops::BitSizeof<word_t>(), bitops::BitSizeof<reg_t>()>(res_w));
    hart->SetPCTarget(hart->GetPC() + sizeof(instr_size_t));

    return Exception::NONE;
}

Exception SRLW(Hart *hart, const Instruction &instr)
{
    reg_t rv1 = hart->GetGPR(instr.rs1);
    reg_t rv2 = hart->GetGPR(instr.rs2);

    reg_t res_w =
        bitops::GetBits<bitops::BitSizeof<word_t>() - 1, 0>(rv1 >> bitops::GetBits<RV_SH_UPPER_BIT_INDEX, 0>(rv2));

    hart->SetGPR(instr.rd, bitops::SignExtend<bitops::BitSizeof<word_t>(), bitops::BitSizeof<reg_t>()>(res_w));
    hart->SetPCTarget(hart->GetPC() + sizeof(instr_size_t));

    return Exception::NONE;
}

Exception SRAW(Hart *hart, const Instruction &instr)
{
    reg_t rv1 = hart->GetGPR(instr.rs1);
    reg_t rv2 = hart->GetGPR(instr.rs2);

    auto shift = bitops::GetBits<RV_SH_UPPER_BIT_INDEX, 0>(rv2);
    reg_t res_w = bitops::GetBits<bitops::BitSizeof<word_t>() - 1, 0>(rv1 >> shift);
    rv1 = bitops::SignExtend(bitops::BitSizeof<reg_t>() - shift, bitops::BitSizeof<reg_t>(), rv1);

    hart->SetGPR(instr.rd, bitops::SignExtend(bitops::BitSizeof<word_t>() - shift, bitops::BitSizeof<reg_t>(), res_w));
    hart->SetPCTarget(hart->GetPC() + sizeof(instr_size_t));

    return Exception::NONE;
}

Exception LB(Hart *hart, const Instruction &instr)
{
    auto rv1 = hart->GetGPR(instr.rs1);

    using load_type_t = std::make_signed_t<byte_t>;
    load_type_t load_value {0};

    Exception exception = hart->LoadFromMemory<load_type_t>(rv1 + instr.imm, &load_value);
    hart->SetGPR(instr.rd, load_value);
    hart->SetPCTarget(hart->GetPC() + sizeof(instr_size_t));

    return exception;
}

Exception LH(Hart *hart, const Instruction &instr)
{
    auto rv1 = hart->GetGPR(instr.rs1);

    using load_type_t = std::make_signed_t<hword_t>;
    load_type_t load_value {0};

    Exception exception = hart->LoadFromMemory<load_type_t>(rv1 + instr.imm, &load_value);
    hart->SetGPR(instr.rd, load_value);
    hart->SetPCTarget(hart->GetPC() + sizeof(instr_size_t));

    return exception;
}

Exception LW(Hart *hart, const Instruction &instr)
{
    auto rv1 = hart->GetGPR(instr.rs1);

    using load_type_t = std::make_signed_t<word_t>;
    load_type_t load_value {0};

    Exception exception = hart->LoadFromMemory<load_type_t>(rv1 + instr.imm, &load_value);
    hart->SetGPR(instr.rd, load_value);
    hart->SetPCTarget(hart->GetPC() + sizeof(instr_size_t));

    return exception;
}

Exception LD(Hart *hart, const Instruction &instr)
{
    auto rv1 = hart->GetGPR(instr.rs1);

    using load_type_t = dword_t;
    load_type_t load_value {0};

    Exception exception = hart->LoadFromMemory<load_type_t>(rv1 + instr.imm, &load_value);
    hart->SetGPR(instr.rd, load_value);
    hart->SetPCTarget(hart->GetPC() + sizeof(instr_size_t));

    return exception;
}

Exception LBU(Hart *hart, const Instruction &instr)
{
    auto rv1 = hart->GetGPR(instr.rs1);

    using load_type_t = byte_t;
    load_type_t load_value {0};

    Exception exception = hart->LoadFromMemory<load_type_t>(rv1 + instr.imm, &load_value);
    hart->SetGPR(instr.rd, load_value);
    hart->SetPCTarget(hart->GetPC() + sizeof(instr_size_t));

    return exception;
}

Exception LHU(Hart *hart, const Instruction &instr)
{
    auto rv1 = hart->GetGPR(instr.rs1);

    using load_type_t = hword_t;
    load_type_t load_value {0};

    Exception exception = hart->LoadFromMemory<load_type_t>(rv1 + instr.imm, &load_value);
    hart->SetGPR(instr.rd, load_value);
    hart->SetPCTarget(hart->GetPC() + sizeof(instr_size_t));

    return exception;
}

Exception LWU(Hart *hart, const Instruction &instr)
{
    auto rv1 = hart->GetGPR(instr.rs1);

    using load_type_t = word_t;
    load_type_t load_value {0};

    Exception exception = hart->LoadFromMemory<load_type_t>(rv1 + instr.imm, &load_value);
    hart->SetGPR(instr.rd, load_value);
    hart->SetPCTarget(hart->GetPC() + sizeof(instr_size_t));

    return exception;
}

Exception SB(Hart *hart, const Instruction &instr)
{
    auto rv1 = hart->GetGPR(instr.rs1);
    byte_t rv2 = hart->GetGPR(instr.rs2);

    Exception exception = hart->StoreToMemory<byte_t>(rv1 + instr.imm, rv2);
    hart->SetPCTarget(hart->GetPC() + sizeof(instr_size_t));

    return exception;
}

Exception SH(Hart *hart, const Instruction &instr)
{
    auto rv1 = hart->GetGPR(instr.rs1);
    hword_t rv2 = hart->GetGPR(instr.rs2);

    Exception exception = hart->StoreToMemory<hword_t>(rv1 + instr.imm, rv2);
    hart->SetPCTarget(hart->GetPC() + sizeof(instr_size_t));

    return exception;
}

Exception SW(Hart *hart, const Instruction &instr)
{
    auto rv1 = hart->GetGPR(instr.rs1);
    word_t rv2 = hart->GetGPR(instr.rs2);

    Exception exception = hart->StoreToMemory<word_t>(rv1 + instr.imm, rv2);
    hart->SetPCTarget(hart->GetPC() + sizeof(instr_size_t));

    return exception;
}

Exception SD(Hart *hart, const Instruction &instr)
{
    auto rv1 = hart->GetGPR(instr.rs1);
    dword_t rv2 = hart->GetGPR(instr.rs2);

    Exception exception = hart->StoreToMemory<dword_t>(rv1 + instr.imm, rv2);
    hart->SetPCTarget(hart->GetPC() + sizeof(instr_size_t));

    return exception;
}

Exception FENCE(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FENCE(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception FENCE_I(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FENCE_I(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception MUL(Hart *hart, const Instruction &instr)
{
    reg_t rv1 = hart->GetGPR(instr.rs1);
    reg_t rv2 = hart->GetGPR(instr.rs2);

    hart->SetGPR(instr.rd, rv1 * rv2);
    hart->SetPCTarget(hart->GetPC() + sizeof(instr_size_t));

    return Exception::NONE;
}

Exception MULH(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::MULH(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception MULHSU(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::MULHSU(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception MULHU(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::MULHU(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception DIV(Hart *hart, const Instruction &instr)
{
    auto rv1 = bitops::MakeSigned(hart->GetGPR(instr.rs1));
    auto rv2 = bitops::MakeSigned(hart->GetGPR(instr.rs2));

    hart->SetGPR(instr.rd, rv1 / rv2);
    hart->SetPCTarget(hart->GetPC() + sizeof(instr_size_t));

    return Exception::NONE;
}

Exception DIVU(Hart *hart, const Instruction &instr)
{
    reg_t rv1 = hart->GetGPR(instr.rs1);
    reg_t rv2 = hart->GetGPR(instr.rs2);

    hart->SetGPR(instr.rd, rv1 / rv2);
    hart->SetPCTarget(hart->GetPC() + sizeof(instr_size_t));

    return Exception::NONE;
}

Exception REM(Hart *hart, const Instruction &instr)
{
    auto rv1 = bitops::MakeSigned(hart->GetGPR(instr.rs1));
    auto rv2 = bitops::MakeSigned(hart->GetGPR(instr.rs2));

    hart->SetGPR(instr.rd, rv1 % rv2);
    hart->SetPCTarget(hart->GetPC() + sizeof(instr_size_t));

    return Exception::NONE;
}

Exception REMU(Hart *hart, const Instruction &instr)
{
    reg_t rv1 = hart->GetGPR(instr.rs1);
    reg_t rv2 = hart->GetGPR(instr.rs2);

    hart->SetGPR(instr.rd, rv1 % rv2);
    hart->SetPCTarget(hart->GetPC() + sizeof(instr_size_t));

    return Exception::NONE;
}

Exception MULW(Hart *hart, const Instruction &instr)
{
    reg_t rv1 = hart->GetGPR(instr.rs1);
    reg_t rv2 = hart->GetGPR(instr.rs2);

    rv1 = bitops::GetBits<bitops::BitSizeof<word_t>() - 1, 0>(rv1);
    rv1 = bitops::SignExtend<bitops::BitSizeof<word_t>(), bitops::BitSizeof<reg_t>()>(rv1);

    rv2 = bitops::GetBits<bitops::BitSizeof<word_t>() - 1, 0>(rv2);
    rv2 = bitops::SignExtend<bitops::BitSizeof<word_t>(), bitops::BitSizeof<reg_t>()>(rv2);

    reg_t res_w = bitops::GetBits<bitops::BitSizeof<word_t>() - 1, 0>(rv1 * rv2);

    hart->SetGPR(instr.rd, bitops::SignExtend<bitops::BitSizeof<word_t>(), bitops::BitSizeof<reg_t>()>(res_w));
    hart->SetPCTarget(hart->GetPC() + sizeof(instr_size_t));

    return Exception::NONE;
}

Exception DIVW(Hart *hart, const Instruction &instr)
{
    auto rv1 = bitops::MakeSigned(hart->GetGPR(instr.rs1));
    auto rv2 = bitops::MakeSigned(hart->GetGPR(instr.rs2));

    rv1 = bitops::GetBits<bitops::BitSizeof<word_t>() - 1, 0>(rv1);
    rv1 = bitops::SignExtend<bitops::BitSizeof<word_t>(), bitops::BitSizeof<reg_t>()>(rv1);

    rv2 = bitops::GetBits<bitops::BitSizeof<word_t>() - 1, 0>(rv2);
    rv2 = bitops::SignExtend<bitops::BitSizeof<word_t>(), bitops::BitSizeof<reg_t>()>(rv2);

    reg_t res_w = bitops::GetBits<bitops::BitSizeof<word_t>() - 1, 0>(rv1 / rv2);

    hart->SetGPR(instr.rd, bitops::SignExtend<bitops::BitSizeof<word_t>(), bitops::BitSizeof<reg_t>()>(res_w));
    hart->SetPCTarget(hart->GetPC() + sizeof(instr_size_t));

    return Exception::NONE;
}

Exception DIVUW(Hart *hart, const Instruction &instr)
{
    reg_t rv1 = hart->GetGPR(instr.rs1);
    reg_t rv2 = hart->GetGPR(instr.rs2);

    rv1 = bitops::GetBits<bitops::BitSizeof<word_t>() - 1, 0>(rv1);
    rv1 = bitops::SignExtend<bitops::BitSizeof<word_t>(), bitops::BitSizeof<reg_t>()>(rv1);

    rv2 = bitops::GetBits<bitops::BitSizeof<word_t>() - 1, 0>(rv2);
    rv2 = bitops::SignExtend<bitops::BitSizeof<word_t>(), bitops::BitSizeof<reg_t>()>(rv2);

    reg_t res_w = bitops::GetBits<bitops::BitSizeof<word_t>() - 1, 0>(rv1 / rv2);

    hart->SetGPR(instr.rd, bitops::SignExtend<bitops::BitSizeof<word_t>(), bitops::BitSizeof<reg_t>()>(res_w));
    hart->SetPCTarget(hart->GetPC() + sizeof(instr_size_t));

    return Exception::NONE;
}

Exception REMW(Hart *hart, const Instruction &instr)
{
    auto rv1 = bitops::MakeSigned(hart->GetGPR(instr.rs1));
    auto rv2 = bitops::MakeSigned(hart->GetGPR(instr.rs2));

    rv1 = bitops::GetBits<bitops::BitSizeof<word_t>() - 1, 0>(rv1);
    rv1 = bitops::SignExtend<bitops::BitSizeof<word_t>(), bitops::BitSizeof<reg_t>()>(rv1);

    rv2 = bitops::GetBits<bitops::BitSizeof<word_t>() - 1, 0>(rv2);
    rv2 = bitops::SignExtend<bitops::BitSizeof<word_t>(), bitops::BitSizeof<reg_t>()>(rv2);

    reg_t res_w = bitops::GetBits<bitops::BitSizeof<word_t>() - 1, 0>(rv1 % rv2);

    hart->SetGPR(instr.rd, bitops::SignExtend<bitops::BitSizeof<word_t>(), bitops::BitSizeof<reg_t>()>(res_w));
    hart->SetPCTarget(hart->GetPC() + sizeof(instr_size_t));

    return Exception::NONE;
}

Exception REMUW(Hart *hart, const Instruction &instr)
{
    reg_t rv1 = hart->GetGPR(instr.rs1);
    reg_t rv2 = hart->GetGPR(instr.rs2);

    rv1 = bitops::GetBits<bitops::BitSizeof<word_t>() - 1, 0>(rv1);
    rv1 = bitops::SignExtend<bitops::BitSizeof<word_t>(), bitops::BitSizeof<reg_t>()>(rv1);

    rv2 = bitops::GetBits<bitops::BitSizeof<word_t>() - 1, 0>(rv2);
    rv2 = bitops::SignExtend<bitops::BitSizeof<word_t>(), bitops::BitSizeof<reg_t>()>(rv2);

    reg_t res_w = bitops::GetBits<bitops::BitSizeof<word_t>() - 1, 0>(rv1 % rv2);

    hart->SetGPR(instr.rd, bitops::SignExtend<bitops::BitSizeof<word_t>(), bitops::BitSizeof<reg_t>()>(res_w));
    hart->SetPCTarget(hart->GetPC() + sizeof(instr_size_t));

    return Exception::NONE;
}

Exception AMOADD_W(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::AMOADD_W(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception AMOXOR_W(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::AMOXOR_W(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception AMOOR_W(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::AMOOR_W(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception AMOAND_W(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::AMOAND_W(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception AMOMIN_W(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::AMOMIN_W(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception AMOMAX_W(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::AMOMAX_W(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception AMOMINU_W(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::AMOMINU_W(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception AMOMAXU_W(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::AMOMAXU_W(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception AMOSWAP_W(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::AMOSWAP_W(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception LR_W(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::LR_W(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception SC_W(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::SC_W(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception AMOADD_D(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::AMOADD_D(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception AMOXOR_D(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::AMOXOR_D(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception AMOOR_D(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::AMOOR_D(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception AMOAND_D(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::AMOAND_D(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception AMOMIN_D(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::AMOMIN_D(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception AMOMAX_D(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::AMOMAX_D(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception AMOMINU_D(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::AMOMINU_D(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception AMOMAXU_D(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::AMOMAXU_D(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception AMOSWAP_D(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::AMOSWAP_D(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception LR_D(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::LR_D(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception SC_D(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::SC_D(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception ECALL(Hart *hart, [[maybe_unused]] const Instruction &instr)
{
    hart->SetIdleStatus(true);

    return Exception::NONE;
}

Exception EBREAK(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::EBREAK(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception URET(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::URET(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception SRET(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::SRET(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception MRET(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::MRET(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception DRET(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::DRET(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception SFENCE_VMA(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::SFENCE_VMA(Hart *hart, const Instruction &instr) is not implemented yet!"
              << std::endl;

    return Exception::NONE;
}

Exception WFI(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::WFI(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception CSRRW(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::CSRRW(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception CSRRS(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::CSRRS(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception CSRRC(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::CSRRC(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception CSRRWI(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::CSRRWI(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception CSRRSI(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::CSRRSI(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception CSRRCI(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::CSRRCI(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception HFENCE_VVMA(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::HFENCE_VVMA(Hart *hart, const Instruction &instr) is not implemented yet!"
              << std::endl;

    return Exception::NONE;
}

Exception HFENCE_GVMA(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::HFENCE_GVMA(Hart *hart, const Instruction &instr) is not implemented yet!"
              << std::endl;

    return Exception::NONE;
}

Exception FADD_S(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FADD_S(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception FSUB_S(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FSUB_S(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception FMUL_S(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FMUL_S(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception FDIV_S(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FDIV_S(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception FSGNJ_S(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FSGNJ_S(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception FSGNJN_S(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FSGNJN_S(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception FSGNJX_S(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FSGNJX_S(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception FMIN_S(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FMIN_S(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception FMAX_S(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FMAX_S(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception FSQRT_S(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FSQRT_S(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception FADD_D(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FADD_D(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception FSUB_D(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FSUB_D(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception FMUL_D(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FMUL_D(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception FDIV_D(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FDIV_D(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception FSGNJ_D(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FSGNJ_D(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception FSGNJN_D(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FSGNJN_D(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception FSGNJX_D(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FSGNJX_D(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception FMIN_D(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FMIN_D(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception FMAX_D(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FMAX_D(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception FCVT_S_D(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FCVT_S_D(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception FCVT_D_S(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FCVT_D_S(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception FSQRT_D(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FSQRT_D(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception FADD_Q(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FADD_Q(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception FSUB_Q(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FSUB_Q(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception FMUL_Q(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FMUL_Q(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception FDIV_Q(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FDIV_Q(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception FSGNJ_Q(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FSGNJ_Q(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception FSGNJN_Q(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FSGNJN_Q(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception FSGNJX_Q(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FSGNJX_Q(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception FMIN_Q(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FMIN_Q(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception FMAX_Q(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FMAX_Q(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception FCVT_S_Q(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FCVT_S_Q(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception FCVT_Q_S(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FCVT_Q_S(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception FCVT_D_Q(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FCVT_D_Q(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception FCVT_Q_D(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FCVT_Q_D(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception FSQRT_Q(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FSQRT_Q(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception FLE_S(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FLE_S(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception FLT_S(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FLT_S(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception FEQ_S(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FEQ_S(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception FLE_D(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FLE_D(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception FLT_D(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FLT_D(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception FEQ_D(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FEQ_D(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception FLE_Q(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FLE_Q(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception FLT_Q(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FLT_Q(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception FEQ_Q(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FEQ_Q(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception FCVT_W_S(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FCVT_W_S(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception FCVT_WU_S(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FCVT_WU_S(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception FCVT_L_S(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FCVT_L_S(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception FCVT_LU_S(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FCVT_LU_S(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception FMV_X_W(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FMV_X_W(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception FCLASS_S(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FCLASS_S(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception FCVT_W_D(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FCVT_W_D(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception FCVT_WU_D(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FCVT_WU_D(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception FCVT_L_D(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FCVT_L_D(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception FCVT_LU_D(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FCVT_LU_D(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception FMV_X_D(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FMV_X_D(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception FCLASS_D(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FCLASS_D(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception FCVT_W_Q(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FCVT_W_Q(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception FCVT_WU_Q(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FCVT_WU_Q(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception FCVT_L_Q(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FCVT_L_Q(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception FCVT_LU_Q(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FCVT_LU_Q(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception FMV_X_Q(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FMV_X_Q(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception FCLASS_Q(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FCLASS_Q(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception FCVT_S_W(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FCVT_S_W(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception FCVT_S_WU(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FCVT_S_WU(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception FCVT_S_L(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FCVT_S_L(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception FCVT_S_LU(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FCVT_S_LU(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception FMV_W_X(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FMV_W_X(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception FCVT_D_W(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FCVT_D_W(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception FCVT_D_WU(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FCVT_D_WU(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception FCVT_D_L(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FCVT_D_L(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception FCVT_D_LU(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FCVT_D_LU(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception FMV_D_X(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FMV_D_X(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception FCVT_Q_W(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FCVT_Q_W(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception FCVT_Q_WU(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FCVT_Q_WU(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;
    return Exception::NONE;
}

Exception FCVT_Q_L(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FCVT_Q_L(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception FCVT_Q_LU(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FCVT_Q_LU(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception FMV_Q_X(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FMV_Q_X(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception FLW(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FLW(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception FLD(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FLD(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception FLQ(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FLQ(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception FSW(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FSW(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception FSD(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FSD(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception FSQ(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FSQ(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception FMADD_S(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FMADD_S(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception FMSUB_S(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FMSUB_S(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception FNMSUB_S(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FNMSUB_S(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception FNMADD_S(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FNMADD_S(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception FMADD_D(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FMADD_D(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception FMSUB_D(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FMSUB_D(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception FNMSUB_D(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FNMSUB_D(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception FNMADD_D(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FNMADD_D(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception FMADD_Q(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FMADD_Q(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception FMSUB_Q(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FMSUB_Q(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception FNMSUB_Q(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FNMSUB_Q(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception FNMADD_Q(Hart *hart, const Instruction &instr)
{
    (void)hart;
    (void)instr;
    std::cerr << "function iexec::FNMADD_Q(Hart *hart, const Instruction &instr) is not implemented yet!" << std::endl;

    return Exception::NONE;
}

Exception INVALID([[maybe_unused]] Hart *hart, [[maybe_unused]] const Instruction &instr)
{
    // TODO(skurnevich): change abort to hart->SetException(InvalidInstr)
    err(EX_DATAERR, "Invalid instruction\n");

    return Exception::NONE;
}

} // namespace iexec

} // namespace rvsim
