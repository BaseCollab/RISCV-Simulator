#!/usr/bin/env python3

import os
import sys
import yaml
import argparse

COMMENT_NO_CHANGE_STR = "/*\n"                                                                      \
                 " * This file is autogenerated by 'generate.py' script from risc-v.yaml file\n"    \
                 " * Do not try to change anything in this file\n"                                  \
                 " ***********************************************************\n"                   \
                 " * AUTHORS:\n"                                                                    \
                 " * Roman Glaz (Vokerlee)\n"                                                       \
                 " * Stanislav Kurnevich (Stan1slavssKy)\n"                                         \
                 "*/\n\n"

COMMENT_WITH_CHANGE_STR = "/*\n"                                                                    \
                 " * This file is autogenerated by 'generate.py' script from risc-v.yaml file\n"    \
                 " * This file can be changed without additional autogeneration\n"                  \
                 " ***********************************************************\n"                   \
                 " * AUTHORS:\n"                                                                    \
                 " * Roman Glaz (Vokerlee)\n"                                                       \
                 " * Stanislav Kurnevich (Stan1slavssKy)\n"                                         \
                 "*/\n\n"

def parse_yaml(filename):
    with open(filename, 'r') as instr_file:
        return yaml.safe_load(instr_file)

def get_bits_str(msb, lsb, word_str):
    return f'bitops::GetBits<{msb}, {lsb}>(' + word_str + ')'

def sort_bits(bits):
    return sorted(bits, key=lambda elem : elem['from'])

def sign_extend_str(old_size, new_size):
    return f'bitops::SignExtend<{old_size}, {new_size}>'

def set_invalid_id():
    print('/* Instruction wasn\'t found */\n' \
          'instr->id = InstructionId::INVALID_ID;\n' \
          '\n' \
          'return;\n' \
          )

def write_fields_fill(decoder_leaf, fields, mode):
    instr_fields = decoder_leaf['fields']
    instr_name = decoder_leaf['mnemonic'].upper().replace('.', '_')

    print(f'instr->id = InstructionId::{instr_name};\n')

    if decoder_leaf['format'] == 'B' or decoder_leaf['mnemonic'] in ['jalr', 'jal', 'ecall']:
        print('instr->attributes.is_branch = true;\n')
    elif decoder_leaf['format'] == 'S':
        print('instr->attributes.is_store = true;\n')
    elif decoder_leaf['format'] == 'I' and instr_name[0] == 'L':
        print('instr->attributes.is_load = true;\n')

    if mode == "privileged":
        if instr_name == 'WFI' or instr_name[0] == 'M':
            print('instr->attributes.mode = Mode::MACHINE_MODE;\n')
        elif instr_name[0] == 'H':
            print('instr->attributes.mode = Mode::HYPERVISOR_MODE;\n')
        elif instr_name[0] == 'S':
            print('instr->attributes.mode = Mode::SUPERVISOR_MODE;\n')

    for field in instr_fields:
        name = fields[field]['name']
        bits_list = fields[field]['location']['bits']
        bits_list = sort_bits(bits_list)

        for elem in bits_list:
            msb, lsb = elem['msb'], elem['lsb']
            move = elem['to']

            # TEMPORARY EXCLUSION
            exclude_list = ['fm', 'pred', 'succ', 'aqrl', 'shamtw', 'shamt']
            if name in exclude_list:
                if name in exclude_list[3:]:
                    msb = 31
                name = 'imm'

            print(f'instr->{name} |= ', end='')
            if name == 'imm' and msb == 31:
                print(f'{sign_extend_str(msb - lsb + 1, "bitops::BitSizeof<word_t>()")}')

            print(f'({get_bits_str(msb, lsb, "raw_instr")})', end='')
            print(';' if move == 0 else f' << {move};')

            if (name == 'rd'):
                print(f'if (instr->{name} == 0) {{')
                print(f'instr->{name} = SINK_REG_IDX;\n', end='')
                print(f'}}\n')

    print(f'\n#ifdef DEBUG_HART\n', end='')
    print(f'std::cerr << \"[DEBUG] [DECODE] \" << std::hex << \"{instr_name}: 0x\" << raw_instr << std::dec << std::endl;\n', end='')
    print(f'#endif // DEBUG_HART\n', end='')

    print(f'\nreturn;\n', end='')

def recursive_parse(decoder_tree, fields, mode):
    if 'range' in decoder_tree:
        opcode_str = get_bits_str(decoder_tree['range']['msb'], decoder_tree['range']['lsb'], 'raw_instr')
        var_name = f'var_bits_{recursive_parse.var_cnt}'

        recursive_parse.var_cnt += 1

        print(f'word_t {var_name} = {opcode_str};')

        for node in decoder_tree['nodes']:
            if recursive_parse.var_cnt == 1 and 0b1110011 == node: # system opcode
                mode = "privileged"

            print(f'if ({var_name} == {node})\n{{')
            recursive_parse(decoder_tree['nodes'][node], fields, mode)
            print('}\n')

            if recursive_parse.var_cnt == 1:
                mode = "unprivileged"

        recursive_parse.var_cnt -= 1
        set_invalid_id()
    else:
        write_fields_fill(decoder_tree, fields, mode)

recursive_parse.var_cnt = 0

def decode_gen(fout, yaml_dict):
    stdout_bak = sys.stdout
    sys.stdout = fout

    recursive_parse(yaml_dict['decodertree'], yaml_dict['fields'], "unprivileged")

    sys.stdout = stdout_bak

def generate_decode_logic(yaml_dict, output_dir):
    file_location = os.path.join(output_dir, 'decoder.cpp')

    with open(file_location, 'w') as fout:
        fout.write(COMMENT_NO_CHANGE_STR)
        fout.write('#include \"hart/hart.h\"\n')
        fout.write('#include \"common/utils/bit_ops.h\"\n')
        fout.write('#include \"instruction/instruction.h\"\n')
        fout.write('namespace rvsim {\n\n')
        fout.write('void Hart::DecodeInstruction(Instruction *instr, instr_size_t raw_instr)\n{\n')

        decode_gen(fout, yaml_dict)

        fout.write('}\n')
        fout.write("\n} // namespace rvsim\n")

def generate_execution_decls(yaml_dict, output_dir):
    instrs = yaml_dict['instructions']

    instrs_mnemonic_list = []
    for instr in instrs:
        instrs_mnemonic_list.append(instr['mnemonic'].upper().replace('.', '_'))

    file_location = os.path.join(output_dir, 'instruction_exec.h')

    with open(file_location, 'w') as fout:
        fout.write(COMMENT_NO_CHANGE_STR)
        fout.write("#ifndef SIMULATOR_INSTRUCTION_EXEC_INSTRUCTION_EXEC_H\n"
                   "#define SIMULATOR_INSTRUCTION_EXEC_INSTRUCTION_EXEC_H\n\n")
        fout.write('#include \"hart/hart.h\"\n')
        fout.write('#include \"hart/exception.h\"\n')
        fout.write('#include \"instruction.h\"\n\n')

        fout.write('namespace rvsim {\n'
                   'namespace iexec {\n\n'
                   '// clang-format off\n\n')

        max_instr_len = max([len(instr) for instr in instrs_mnemonic_list])

        for i in range(len(instrs_mnemonic_list)):
            fout.write(f'Exception {instrs_mnemonic_list[i]}' + \
                        ' ' * (max_instr_len - len(instrs_mnemonic_list[i])) + '(Hart &hart, const Instruction &instr);\n')

        fout.write('\n// clang-format on\n')
        fout.write("\n} // namespace iexec\n")
        fout.write("} // namespace rvsim\n\n")
        fout.write("#endif // SIMULATOR_INSTRUCTION_EXEC_INSTRUCTION_EXEC_H\n")

    file_location = os.path.join(output_dir, 'instruction_exec.cpp')

    with open(file_location, 'w') as fout:
        fout.write(COMMENT_WITH_CHANGE_STR)
        fout.write('#include \"instruction_exec.h\"\n\n')

        fout.write('namespace rvsim {\n'
                   'namespace iexec {\n\n')

        max_instr_len = max([len(instr) for instr in instrs_mnemonic_list])

        for i in range(len(instrs_mnemonic_list)):
            fout.write(f'Exception {instrs_mnemonic_list[i]}(Hart &hart, const Instruction &instr)\n'
                        '{\n')
            fout.write('    (void) hart;\n')
            fout.write('    (void) instr;\n')
            fout.write(f'    std::cerr << \"function iexec::{instrs_mnemonic_list[i]}(Hart &hart, const Instruction &instr) '
                       'is not implemented yet!\" << std::endl;\n')
            fout.write("}\n\n")

        fout.write("} // namespace iexec\n")
        fout.write("\n} // namespace rvsim\n")

def generate_id_enum(yaml_dict, output_dir):
    instrs = yaml_dict['instructions']

    instrs_mnemonic_list = []
    for instr in instrs:
        instrs_mnemonic_list.append(instr['mnemonic'].upper().replace('.', '_'))

    instrs_mnemonic_list.append('BB_END')
    instrs_mnemonic_list.append('PSEUDO') # pseudo cmd for plugin implementation, should be the last one

    file_location = os.path.join(output_dir, 'instruction_id.h')

    with open(file_location, 'w') as fout:
        fout.write(COMMENT_NO_CHANGE_STR)
        fout.write("#ifndef SIMULATOR_INSTRUCTION_ID_INSTRUCTION_ID_H\n"
                   "#define SIMULATOR_INSTRUCTION_ID_INSTRUCTION_ID_H\n\n"
                   "namespace rvsim {\n\n"
                   "// clang-format off\n\n")

        fout.write('enum class InstructionId\n'
                   '{\n')

        max_instr_len = max([len(instr) for instr in instrs_mnemonic_list])

        fout.write('    INVALID_ID' + ' ' * (max_instr_len - len('INVALID_ID')) + ' = -1,\n')

        for i in range(len(instrs_mnemonic_list)):
            fout.write(f'    {instrs_mnemonic_list[i]}' + ' ' * (max_instr_len - len(instrs_mnemonic_list[i])) + \
                       ' = ' + str(i) + ',\n')

        fout.write("};\n\n"
                   "// clang-format on\n\n"
                   "} // namespace rvsim\n\n")

        fout.write("#endif // SIMULATOR_INSTRUCTION_ID_INSTRUCTION_ID_H\n")

def generate_instr_def(yaml_dict, output_dir):
    instrs = yaml_dict['instructions']

    instrs_mnemonic_list = []
    for instr in instrs:
        instrs_mnemonic_list.append(instr['mnemonic'].upper().replace('.', '_'))

    instrs_mnemonic_list.append('PSEUDO') # pseudo cmd for plugin implementation

    branch_mnemonic_list = ['BEQ', 'BNE', 'BLT', 'BGE', 'BLTU', 'BGEU', 'JALR', 'JAL', 'ECALL']

    file_location = os.path.join(output_dir, 'instruction.def')

    with open(file_location, 'w') as fout:
        fout.write(COMMENT_NO_CHANGE_STR)

        for i in range(len(instrs_mnemonic_list)):
            if instrs_mnemonic_list[i] in branch_mnemonic_list:
                fout.write(f'DEFINE_BRANCH_INSTR({instrs_mnemonic_list[i]}) // NOTE: branch instruction\n')  
            elif instrs_mnemonic_list[i] == 'PSEUDO':
                continue
            else:
                fout.write(f'DEFINE_INSTR({instrs_mnemonic_list[i]})\n')

        fout.write(f'DEFINE_BRANCH_INSTR(BB_END) // NOTE: branch instruction\n')  

def parse_args():
    parser = argparse.ArgumentParser(prog='generate.py')

    parser.add_argument('filepath', help='path to the yaml file')
    parser.add_argument('outdir', help='path to the output directory')
    parser.add_argument('mode',
                        choices=['all', 'iexec', 'iid', 'idef', 'decoder'],
                        default='all',
                        help='file to generate')

    return parser.parse_args()

def run_gen(args, yaml_dict):
    if args.mode == 'all':
        generate_id_enum(yaml_dict, args.outdir)
        generate_decode_logic(yaml_dict, args.outdir)
        generate_execution_decls(yaml_dict, args.outdir)
        generate_instr_def(yaml_dict, args.outdir)

    elif args.mode == 'iexec':
        generate_execution_decls(yaml_dict, args.outdir)

    elif args.mode == 'iid':
        generate_id_enum(yaml_dict, args.outdir)

    elif args.mode == 'idef':
        generate_instr_def(yaml_dict, args.outdir)

    elif args.mode == 'decoder':
        generate_decode_logic(yaml_dict, args.outdir)

def main():
    args = parse_args()
    yaml_dict = parse_yaml(args.filepath)
    run_gen(args, yaml_dict)

if __name__ == '__main__':
    main()
